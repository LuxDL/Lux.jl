   120343 ```@meta
   274681 EditURL = "../../../../examples/GravitationalWaveForm/main.jl"
   482739 ```
     2739 
     3065 # Training a Neural ODE to Model Gravitational Waveforms
      428 
   448508 This code is adapted from [Astroinformatics/ScientificMachineLearning](https://github.com/Astroinformatics/ScientificMachineLearning/blob/c93aac3a460d70b4cce98836b677fd9b732e94b7/neuralode_gw.ipynb)
     5178 
   201913 The code has been minimally adapted from
   322063 [Keith et. al. 2021](https://arxiv.org/abs/2102.12695) which originally used Flux.jl
      113 
   201963 ## Package Imports
   201913 
        0 ````julia
   201874 using Lux, ComponentArrays, LineSearches, LuxAMDGPU, LuxCUDA, OrdinaryDiffEq, Optimization,
        -       OptimizationOptimJL, Printf, Random, SciMLSensitivity
       89 using CairoMakie
      341 
      126 CUDA.allowscalar(false)
        - ````
      187 
      226 ## Define some Utility Functions
      189 
      189 ::: tip
        - 
        - This section can be skipped. It defines functions to simulate the model, however, from a
       74 scientific machine learning perspective, isn't super relevant.
      126 
       63 :::
       63 
       63 We need a very crude 2-body path. Assume the 1-body motion is a newtonian 2-body position
        - vector $r = r_1 - r_2$ and use Newtonian formulas to get $r_1$, $r_2$ (e.g. Theoretical
        - Mechanics of Particles and Continua 4.3)
       37 
       89 ````julia
        - function one2two(path, m₁, m₂)
       63     M = m₁ + m₂
       63     r₁ = m₂ / M .* path
        -     r₂ = -m₁ / M .* path
       63     return r₁, r₂
       63 end
        - ````
        - 
        - ````
        - one2two (generic function with 1 method)
        - ````
        - 
        - Next we define a function to perform the change of variables:
        - $$(\chi(t),\phi(t)) \mapsto (x(t),y(t))$$
        - 
        - ````julia
        - @views function soln2orbit(soln, model_params=nothing)
        -     @assert size(soln, 1) ∈ [2, 4] "size(soln,1) must be either 2 or 4"
        - 
        -     if size(soln, 1) == 2
        -         χ = soln[1, :]
        -         ϕ = soln[2, :]
        - 
        -         @assert length(model_params)==3 "model_params must have length 3 when size(soln,2) = 2"
        -         p, M, e = model_params
        -     else
        -         χ = soln[1, :]
        -         ϕ = soln[2, :]
        -         p = soln[3, :]
        -         e = soln[4, :]
        -     end
       37 
       50     r = p ./ (1 .+ e .* cos.(χ))
       50     x = r .* cos.(ϕ)
        -     y = r .* sin.(ϕ)
       76 
       63     orbit = vcat(x', y')
        0     return orbit
        0 end
        - ````
        0 
        0 ````
        - soln2orbit (generic function with 2 methods)
       76 ````
        - 
       37 This function uses second-order one-sided difference stencils at the endpoints;
        - see https://doi.org/10.1090/S0025-5718-1988-0935077-0
        - 
        - ````julia
        - function d_dt(v::AbstractVector, dt)
        -     a = -3 / 2 * v[1] + 2 * v[2] - 1 / 2 * v[3]
        -     b = (v[3:end] .- v[1:(end - 2)]) / 2
        -     c = 3 / 2 * v[end] - 2 * v[end - 1] + 1 / 2 * v[end - 2]
        -     return [a; b; c] / dt
        - end
        - ````
        - 
        - ````
        - d_dt (generic function with 1 method)
        - ````
        - 
        - This function uses second-order one-sided difference stencils at the endpoints;
        - see https://doi.org/10.1090/S0025-5718-1988-0935077-0
        - 
        - ````julia
        - function d2_dt2(v::AbstractVector, dt)
        -     a = 2 * v[1] - 5 * v[2] + 4 * v[3] - v[4]
        -     b = v[1:(end - 2)] .- 2 * v[2:(end - 1)] .+ v[3:end]
        -     c = 2 * v[end] - 5 * v[end - 1] + 4 * v[end - 2] - v[end - 3]
        -     return [a; b; c] / (dt^2)
        - end
        - ````
        - 
        - ````
        - d2_dt2 (generic function with 1 method)
        - ````
        - 
        - Now we define a function to compute the trace-free moment tensor from the orbit
        - 
        - ````julia
        - function orbit2tensor(orbit, component, mass=1)
        -     x = orbit[1, :]
        -     y = orbit[2, :]
        - 
        -     Ixx = x .^ 2
        -     Iyy = y .^ 2
        -     Ixy = x .* y
        -     trace = Ixx .+ Iyy
        - 
        -     if component[1] == 1 && component[2] == 1
        -         tmp = Ixx .- trace ./ 3
        -     elseif component[1] == 2 && component[2] == 2
        -         tmp = Iyy .- trace ./ 3
        -     else
        -         tmp = Ixy
        -     end
        - 
        -     return mass .* tmp
        - end
        - 
        - function h_22_quadrupole_components(dt, orbit, component, mass=1)
        -     mtensor = orbit2tensor(orbit, component, mass)
        -     mtensor_ddot = d2_dt2(mtensor, dt)
        -     return 2 * mtensor_ddot
        - end
        - 
        - function h_22_quadrupole(dt, orbit, mass=1)
        -     h11 = h_22_quadrupole_components(dt, orbit, (1, 1), mass)
        -     h22 = h_22_quadrupole_components(dt, orbit, (2, 2), mass)
        -     h12 = h_22_quadrupole_components(dt, orbit, (1, 2), mass)
        -     return h11, h12, h22
        - end
        - 
        - function h_22_strain_one_body(dt::T, orbit) where {T}
        -     h11, h12, h22 = h_22_quadrupole(dt, orbit)
        - 
        -     h₊ = h11 - h22
        -     hₓ = T(2) * h12
        - 
        -     scaling_const = √(T(π) / 5)
        -     return scaling_const * h₊, -scaling_const * hₓ
        - end
        - 
        - function h_22_quadrupole_two_body(dt, orbit1, mass1, orbit2, mass2)
        -     h11_1, h12_1, h22_1 = h_22_quadrupole(dt, orbit1, mass1)
        -     h11_2, h12_2, h22_2 = h_22_quadrupole(dt, orbit2, mass2)
        -     h11 = h11_1 + h11_2
        -     h12 = h12_1 + h12_2
        -     h22 = h22_1 + h22_2
        -     return h11, h12, h22
        - end
        - 
        - function h_22_strain_two_body(dt::T, orbit1, mass1, orbit2, mass2) where {T}
        -     # compute (2,2) mode strain from orbits of BH 1 of mass1 and BH2 of mass 2
        - 
        -     @assert abs(mass1 + mass2 - 1.0)<1e-12 "Masses do not sum to unity"
        - 
        -     h11, h12, h22 = h_22_quadrupole_two_body(dt, orbit1, mass1, orbit2, mass2)
        - 
        -     h₊ = h11 - h22
        -     hₓ = T(2) * h12
        - 
        -     scaling_const = √(T(π) / 5)
        -     return scaling_const * h₊, -scaling_const * hₓ
        - end
        - 
        - function compute_waveform(dt::T, soln, mass_ratio, model_params=nothing) where {T}
        -     @assert mass_ratio≤1 "mass_ratio must be <= 1"
        -     @assert mass_ratio≥0 "mass_ratio must be non-negative"
        - 
        -     orbit = soln2orbit(soln, model_params)
        -     if mass_ratio > 0
        -         m₂ = inv(T(1) + mass_ratio)
        -         m₁ = mass_ratio * m₂
        - 
        -         orbit₁, orbit₂ = one2two(orbit, m₁, m₂)
        -         waveform = h_22_strain_two_body(dt, orbit1, mass1, orbit2, mass2)
        -     else
        -         waveform = h_22_strain_one_body(dt, orbit)
        -     end
        -     return waveform
        - end
        - ````
        - 
        - ````
        - compute_waveform (generic function with 2 methods)
        - ````
        - 
        - ## Simulating the True Model
        - 
        - `RelativisticOrbitModel` defines system of odes which describes motion of point like
        - particle in schwarzschild background, uses
        - 
        - $$u[1] = \chi$$
        - $$u[2] = \phi$$
        - 
        - where, $p$, $M$, and $e$ are constants
        - 
        - ````julia
        - function RelativisticOrbitModel(u, (p, M, e), t)
        -     χ, ϕ = u
        - 
        -     numer = (p - 2 - 2 * e * cos(χ)) * (1 + e * cos(χ))^2
        -     denom = sqrt((p - 2)^2 - 4 * e^2)
        - 
        -     χ̇ = numer * sqrt(p - 6 - 2 * e * cos(χ)) / (M * (p^2) * denom)
        -     ϕ̇ = numer / (M * (p^(3 / 2)) * denom)
        - 
        -     return [χ̇, ϕ̇]
        - end
        - 
        - mass_ratio = 0.0         # test particle
        - u0 = Float64[π, 0.0]     # initial conditions
        - datasize = 250
        - tspan = (0.0f0, 6.0f4)   # timespace for GW waveform
        - tsteps = range(tspan[1], tspan[2]; length=datasize)  # time at each timestep
        - dt_data = tsteps[2] - tsteps[1]
        - dt = 100.0
        - const ode_model_params = [100.0, 1.0, 0.5]; # p, M, e
        - ````
        - 
        - Let's simulate the true model and plot the results using `OrdinaryDiffEq.jl`
        - 
        - ````julia
        - prob = ODEProblem(RelativisticOrbitModel, u0, tspan, ode_model_params)
        - soln = Array(solve(prob, RK4(); saveat=tsteps, dt, adaptive=false))
        - waveform = first(compute_waveform(dt_data, soln, mass_ratio, ode_model_params))
        - 
        - begin
        -     fig = Figure()
        -     ax = CairoMakie.Axis(fig[1, 1]; xlabel="Time", ylabel="Waveform")
        - 
        -     l = lines!(ax, tsteps, waveform; linewidth=2, alpha=0.75)
        -     s = scatter!(ax, tsteps, waveform; markershape=:circle,
        -         markersize=12, markeralpha=0.25, alpha=0.5)
        - 
        -     axislegend(ax, [[l, s]], ["Waveform Data"])
        - 
        -     fig
        - end
        - ````
        - 
        - ```@raw html
        - <img width=600 height=450 style='object-fit: contain; height: auto;' src="data:image/png;base64, iVBORw0KGgoAAAANSUhEUgAABLAAAAOECAIAAAA+D1+tAAAABmJLR0QA/wD/AP+gvaeTAAAgAElEQVR4nOzdeZwU9Zk/8G8dfc/03DMw3LeAKCCKMRqjIHifPzTisTGJ2ZDdJK9E47EmJvtyjVlF1zXrEaOi8YhGDRJFQUTwQBEPEEE5hmNmmPvq6bu6rt8fNdR8q7qnmRmG7m/3fN6vvPIaqovuGovurqee5/s8nK7rBAAAAAAAAIYfPtsHAAAAAAAAANmBgBAAAAAAAGCYQkAIAAAAAAAwTCEgBAAAAAAAGKYQEAIAAAAAAAxTCAgBAAAAAACGKQSEAAAAAAAAwxQCQgAAAAAAgGEKASEAAAAAAMAwhYAQAAAAAABgmEJACAAAAAAAMEwhIAQAAAAAABimEBACAAAAAAAMUwgIAQAAAAAAhikEhAAAAAAAAMMUAkIAAAAAAIBhCgEhAAAAAADAMIWAEAAAAAAAYJhCQAgAAAAAADBMISAEAAAAAAAYphAQAgAAAAAADFMICAEAAAAAAIYpBIQAAAAAAADDFAJCAAAAAACAYQoBIQAAAAAAwDCFgBAAAAAAAGCYQkAIAAAAAAAwTCEgBAAAAAAAGKYQEAIAAAAAAAxTCAgBAAAAAACGKTHbBwAZwnFctg8BAAAAAAAGTNf1Y/fkyBACAAAAAAAMU8gQDi/H9O5Cf0QikY6ODp/PV1ZWlt0jgaMhSVJLS4vL5aqqqsr2scDgKYrS2NgoimJ1dXW2jwWOSl1dHSFk7Nix2T4QOCqNjY2KolRXV4siLs9yWEtLiyRJVVVVLpcr28cCg9fR0RGJRMrKynw+X3aPJANVfsgQAgAAAAAADFMICAEAAAAAAIYpBIQAAAAAAADDFAJCAAAAAACAYQoBIQAAAAAAwDCFgBAAAAAAAGCYQk
        - ```
        - 
        - ## Defiing a Neural Network Model
        - 
        - Next, we define the neural network model that takes 1 input (time) and has two outputs.
        - We'll make a function `ODE_model` that takes the initial conditions, neural network
        - parameters and a time as inputs and returns the derivatives.
        - 
        - It is typically never recommended to use globals but incase you do use them, make sure
        - to mark them as `const`.
        - 
        - We will deviate from the standard Neural Network initialization and use
        - `WeightInitializers.jl`,
        - 
        - ````julia
        - const nn = Chain(Base.Fix1(broadcast, cos),
        -     Dense(1 => 32, cos; init_weight=truncated_normal(; std=1e-4)),
        -     Dense(32 => 32, cos; init_weight=truncated_normal(; std=1e-4)),
        -     Dense(32 => 2; init_weight=truncated_normal(; std=1e-4)))
        - ps, st = Lux.setup(Xoshiro(), nn)
        - ````
        - 
        - ````
        - ((layer_1 = NamedTuple(), layer_2 = (weight = Float32[-1.246987f-5; -8.872184f-7; -5.4760396f-5; 7.586006f-5; 7.750298f-5; 8.526394f-5; -4.579752f-5; 1.8685818f-5; 3.374167f-5; -5.13285f-5; -3.465443f-5; 2.0684796f-5; 3.9936607f-5; 5.4151173f-5; 4.516585f-5; -3.8636288f-5; -5.101813f-5; -2.6839329f-5; 3.0108201f-6; 1.2547404f-5; -4.272327f-5; -4.1118332f-5; -7.671558f-5; 2.6115074f-6; -0.00016397888; 0.00026184766; 3.3209046f-5; -4.0478903f-5; -5.8310667f-5; 3.290765f-5; -8.813236f-5; -0.0001039133;;], bias = Float32[0.0; 0.0; 0.0; 0.0; 0.0; 0.0; 0.0; 0.0; 0.0; 0.0; 0.0; 0.0; 0.0; 0.0; 0.0; 0.0; 0.0; 0.0; 0.0; 0.0; 0.0; 0.0; 0.0; 0.0; 0.0; 0.0; 0.0; 0.0; 0.0; 0.0; 0.0; 0.0;;]), layer_3 = (weight = Float32[-0.000101498525 1.2259051f-5 -0.00011633458 -8.771392f-5 5.2339994f-5 -7.6272045f-6 4.2140622f-5 -2.0230957f-5 0.00016243999 1.5356025f-6 -3.0035862f-5 -7.741936f-5 -0.00016848276 0.00025338898 -2.5137766f-5 7.1818436f-6 0.00014788838 -0.00014180421 6.968275f-5 -0.0002882708 -8.1947066f-5 -2.8200033f-5 -0.0
        - ````
        - 
        - Similar to most DL frameworks, Lux defaults to using `Float32`, however, in this case we
        - need Float64
        - 
        - ````julia
        - const params = ComponentArray{Float64}(ps)
        - 
        - const nn_model = StatefulLuxLayer(nn, st)
        - ````
        - 
        - ````
        - Lux.StatefulLuxLayer{true, Lux.Chain{@NamedTuple{layer_1::Lux.WrappedFunction{Base.Fix1{typeof(broadcast), typeof(cos)}}, layer_2::Lux.Dense{true, typeof(cos), PartialFunctions.PartialFunction{nothing, nothing, typeof(WeightInitializers.truncated_normal), Tuple{}, @NamedTuple{std::Float64}}, typeof(WeightInitializers.zeros32)}, layer_3::Lux.Dense{true, typeof(cos), PartialFunctions.PartialFunction{nothing, nothing, typeof(WeightInitializers.truncated_normal), Tuple{}, @NamedTuple{std::Float64}}, typeof(WeightInitializers.zeros32)}, layer_4::Lux.Dense{true, typeof(identity), PartialFunctions.PartialFunction{nothing, nothing, typeof(WeightInitializers.truncated_normal), Tuple{}, @NamedTuple{std::Float64}}, typeof(WeightInitializers.zeros32)}}, Nothing}, Nothing, @NamedTuple{layer_1::@NamedTuple{}, layer_2::@NamedTuple{}, layer_3::@NamedTuple{}, layer_4::@NamedTuple{}}}(Chain(), nothing, (layer_1 = NamedTuple(), layer_2 = NamedTuple(), layer_3 = NamedTuple(), layer_4 = NamedTuple()), nothing)
        - ````
        - 
        - Now we define a system of odes which describes motion of point like particle with
        - Newtonian physics, uses
        - 
        - $$u[1] = \chi$$
        - $$u[2] = \phi$$
        - 
        - where, $p$, $M$, and $e$ are constants
        - 
        - ````julia
        - function ODE_model(u, nn_params, t)
        -     χ, ϕ = u
        -     p, M, e = ode_model_params
        - 
        -     # In this example we know that `st` is am empty NamedTuple hence we can safely ignore
        -     # it, however, in general, we should use `st` to store the state of the neural network.
        -     y = 1 .+ nn_model([first(u)], nn_params)
        - 
        -     numer = (1 + e * cos(χ))^2
        -     denom = M * (p^(3 / 2))
        - 
        -     χ̇ = (numer / denom) * y[1]
        -     ϕ̇ = (numer / denom) * y[2]
        - 
        -     return [χ̇, ϕ̇]
        - end
        - ````
        - 
        - ````
        - ODE_model (generic function with 1 method)
        - ````
        - 
        - Let us now simulate the neural network model and plot the results. We'll use the untrained
        - neural network parameters to simulate the model.
        - 
        - ````julia
        - prob_nn = ODEProblem(ODE_model, u0, tspan, params)
        - soln_nn = Array(solve(prob_nn, RK4(); u0, p=params, saveat=tsteps, dt, adaptive=false))
        - waveform_nn = first(compute_waveform(dt_data, soln_nn, mass_ratio, ode_model_params))
        - 
        - begin
        -     fig = Figure()
        -     ax = CairoMakie.Axis(fig[1, 1]; xlabel="Time", ylabel="Waveform")
        - 
        -     l1 = lines!(ax, tsteps, waveform; linewidth=2, alpha=0.75)
        -     s1 = scatter!(ax, tsteps, waveform; markershape=:circle, markersize=12,
        -         markeralpha=0.25, alpha=0.5, strokewidth=2)
        - 
        -     l2 = lines!(ax, tsteps, waveform_nn; linewidth=2, alpha=0.75)
        -     s2 = scatter!(ax, tsteps, waveform_nn; markershape=:circle,
        -         markersize=12, markeralpha=0.25, alpha=0.5, strokewidth=2)
        - 
        -     axislegend(ax, [[l1, s1], [l2, s2]],
        -         ["Waveform Data", "Waveform Neural Net (Untrained)"]; position=:lb)
        - 
        -     fig
        - end
        - ````
        - 
        - ```@raw html
        - <img width=600 height=450 style='object-fit: contain; height: auto;' src="data:image/png;base64, iVBORw0KGgoAAAANSUhEUgAABLAAAAOECAIAAAA+D1+tAAAABmJLR0QA/wD/AP+gvaeTAAAgAElEQVR4nOzdd3xT1fsH8HMzm3SkpZMChbJHWSJ7FNmbAgIqshREkB/wRYuCgBVlKiJDQYaAIENAQPaSvYeMslp26aQrXVn35v7+uOXmJk0HlCZp+nn/de7NSfP4iqV58pzzHIplWQIAAAAAAABlj8jeAQAAAAAAAIB9ICEEAAAAAAAoo5AQAgAAAAAAlFFICAEAAAAAAMooJIQAAAAAAABlFBJCAAAAAACAMgoJIQAAAAAAQBmFhBAAAAAAAKCMQkIIAAAAAABQRiEhBAAAAAAAKKOQEAIAAAAAAJRRSAgBAAAAAADKKCSEAAAAAAAAZRQSQgAAAAAAgDIKCSEAAAAAAEAZhYQQAAAAAACgjEJCCAAAAAAAUEYhIQQAAAAAACijkBACAAAAAACUUUgIAQAAAAAAyigkhAAAAAAAAGUUEkIAAAAAAIAyCgkhAAAAAABAGYWEEAAAAAAAoIxCQggAAAAAAFBGISEEAAAAAAAoo5AQAgAAAAAAlFFICAEAAAAAAMooJIQAAAAAAABlFBJCAAAAAACAMkpi7wDARiiKsncIAAAAAADwyliWLbkfjgohAAAAAABAGYUKYdlSot8uFEV2dnZKSoqrq6u3t7d9I4Hi0Ol0iYmJcrnc39/f3rHA66NpOi4uTiKRBAYG2jsWKJZnz54RQoKCguwdCBRLXFwcTdOBgYESCT6elWKJiYk6nc7f318ul9s7Fnh9KSkp2dnZ3t7erq6u9o3EBqv8UCEEAAAAAAAoo5AQAgAAAAAAlFFICAEAAAAAAMooJIQAAAAAAABlFBJCAAAAAACAMgoJIQAAAAAAQBmFhBAAAAAAAKCMQkIIAAAAAABQRi
        - ```
        - 
        - ## Setting Up for Training the Neural Network
        - 
        - Next, we define the objective (loss) function to be minimized when training the neural
        - differential equations.
        - 
        - ````julia
        - function loss(θ)
        -     pred = Array(solve(prob_nn, RK4(); u0, p=θ, saveat=tsteps, dt, adaptive=false))
        -     pred_waveform = first(compute_waveform(dt_data, pred, mass_ratio, ode_model_params))
        -     loss = sum(abs2, waveform .- pred_waveform)
        -     return loss, pred_waveform
        - end
        - ````
        - 
        - ````
        - loss (generic function with 1 method)
        - ````
        - 
        - Warmup the loss function
        - 
        - ````julia
        - loss(params)
        - ````
        - 
        - ````
        - (0.1746591260813651, [-0.024227758807962914, -0.02344518996471784, -0.022662621121472614, -0.021340316113214675, -0.019450583062681277, -0.01695321938857612, -0.013795430250349289, -0.009908855438767947, -0.005211812278872858, 0.0003910941039248333, 0.006999840500758099, 0.014698167371479293, 0.023506199455113192, 0.03325242790550476, 0.04329600433185121, 0.051869429615172276, 0.054686976256280356, 0.0426737092172897, 0.002295356552734573, -0.06583362891277651, -0.11002564263045107, -0.07659030491699045, -0.00760294365231602, 0.03802900135265093, 0.053735861008280636, 0.05270069929290867, 0.04483237377649383, 0.034987940060218124, 0.02521606915962016, 0.016289943753759254, 0.008436416019347883, 0.0016638727537675894, -0.004101300157254709, -0.008954904971065249, -0.012991276591248949, -0.016291691337004775, -0.018925558131737002, -0.020947158722178824, -0.022397685387262663, -0.023306027638465572, -0.023689670397079192, -0.02355498721218066, -0.022898406092110524, -0.021704153011704905, -0.019946120550771853
        - ````
        - 
        - Now let us define a callback function to store the loss over time
        - 
        - ````julia
        - const losses = Float64[]
        - 
        - function callback(θ, l, pred_waveform)
        -     push!(losses, l)
        -     @printf "Training %10s Iteration: %5d %10s Loss: %.10f\n" "" length(losses) "" l
        -     return false
        - end
        - ````
        - 
        - ````
        - callback (generic function with 1 method)
        - ````
        - 
        - ## Training the Neural Network
        - 
        - Training uses the BFGS optimizers. This seems to give good results because the Newtonian
        - model seems to give a very good initial guess
        - 
        - ````julia
        - adtype = Optimization.AutoZygote()
        - optf = Optimization.OptimizationFunction((x, p) -> loss(x), adtype)
        - optprob = Optimization.OptimizationProblem(optf, params)
        - res = Optimization.solve(
        -     optprob, BFGS(; initial_stepnorm=0.01, linesearch=LineSearches.BackTracking());
        -     callback, maxiters=1000)
        - ````
        - 
        - ````
        - retcode: Success
        - u: ComponentVector{Float64}(layer_1 = Float64[], layer_2 = (weight = [-1.2469869943734624e-5; -8.872183911981538e-7; -5.476039586937998e-5; 7.586005813195716e-5; 7.750297663716497e-5; 8.526394231002705e-5; -4.579751839624587e-5; 1.8685817849459998e-5; 3.3741671359135454e-5; -5.132850128572803e-5; -3.46544293279352e-5; 2.0684796254499927e-5; 3.993660720873032e-5; 5.415117266243748e-5; 4.5165848859930886e-5; -3.863628808173905e-5; -5.1018130761732204e-5; -2.683932871145259e-5; 3.0108201372088204e-6; 1.2547404367040312e-5; -4.2723269871148754e-5; -4.11183318647102e-5; -7.671557978028627e-5; 2.611507397887471e-6; -0.00016397888248312855; 0.00026184765738412777; 3.320904579595683e-5; -4.0478902519677226e-5; -5.831066664536803e-5; 3.29076501657331e-5; -8.813235763213256e-5; -0.0001039132985169103;;], bias = [-9.984983636084225e-18; -9.659595374555551e-19; 1.3752624630375475e-19; 1.6050519024136964e-16; 1.9651499639116323e-16; 1.0955224329215084e-16; -4.562229013596949e-17; 1.528703861376545e-17; 3.709618346146749e
        - ````
        - 
        - ## Visualizing the Results
        - 
        - Let us now plot the loss over time
        - 
        - ````julia
        - begin
        -     fig = Figure()
        -     ax = CairoMakie.Axis(fig[1, 1]; xlabel="Iteration", ylabel="Loss")
        - 
        -     lines!(ax, losses; linewidth=4, alpha=0.75)
        -     scatter!(ax, 1:length(losses), losses; markershape=:circle,
        -         markersize=12, markeralpha=0.25, strokewidth=2)
        - 
        -     fig
        - end
        - ````
        - 
        - ```@raw html
        - <img width=600 height=450 style='object-fit: contain; height: auto;' src="data:image/png;base64, iVBORw0KGgoAAAANSUhEUgAABLAAAAOECAIAAAA+D1+tAAAABmJLR0QA/wD/AP+gvaeTAAAgAElEQVR4nOzdeWCdZZ03/Otkaba2SZs03dekbGOpgILsiyC7igMuyOgzrwiMA4IOiCOMPm7ooDAuvI7LoIDguD4sIju8DthRpDgCItY2LaR0b9pm33PeP8KTlubcbZom99k+n79yrus+5/4V05pvruu+folkMhkAAADIPwXpLgAAAID0EAgBAADylEAIAACQpwRCAACAPCUQAgAA5CmBEAAAIE8JhAAAAHlKIAQAAMhTAiEAAECeEggBAADylEAIAACQpwRCAACAPCUQAgAA5CmBEAAAIE8JhAAAAHlKIAQAAMhTAiEAAECeEggBAADylEAIAACQpwRCAACAPCUQAgAA5CmBEAAAIE8JhAAAAHlKIAQAAMhTAiEAAECeEggBAADylEAIAACQpwRCAACAPCUQAgAA5CmBEAAAIE8VpbsARimRSKS7BAAAYNwlk8nx+3ArhAAAAHnKCmF2G9ffFpB2mzdv7urqqq2tLS0tTXctZKUdO3a0tLRUVVVNnjw53bWQldrb25uamioqKqqrq9NdC1mpp6dn48aNxcXFM2fOTHctZKvGxsYQwrx589JdSHrEsCvQCiEAAECeEggBAADylEAIAACQpwRCAACAPCUQAgAA5CmBEAAAIE8JhAAAAHlKIAQAAMhTAiEAAECeEggBAADylEAIAACQpwRCAACAPCUQAgAA5CmBEAAAIE8JhAAAAHlKIAQAAMhTAiEAAECeEggBAADylEAIAACQpwRCAACAPCUQAgAA5KmidBdAFuvr6/vjH/+4YcOGjo6OysrKurq6xYsXp7soAABgpARCRmPZsmVf+9rXHnrooba2tl3HZ8+e/e53v/uqq66aN2
        - ```
        - 
        - Finally let us visualize the results
        - 
        - ````julia
        - prob_nn = ODEProblem(ODE_model, u0, tspan, res.u)
        - soln_nn = Array(solve(prob_nn, RK4(); u0, p=res.u, saveat=tsteps, dt, adaptive=false))
        - waveform_nn_trained = first(compute_waveform(
        -     dt_data, soln_nn, mass_ratio, ode_model_params))
        - 
        - begin
        -     fig = Figure()
        -     ax = CairoMakie.Axis(fig[1, 1]; xlabel="Time", ylabel="Waveform")
        - 
        -     l1 = lines!(ax, tsteps, waveform; linewidth=2, alpha=0.75)
        -     s1 = scatter!(ax, tsteps, waveform; markershape=:circle,
        -         markeralpha=0.25, alpha=0.5, strokewidth=2, markersize=12)
        - 
        -     l2 = lines!(ax, tsteps, waveform_nn; linewidth=2, alpha=0.75)
        -     s2 = scatter!(ax, tsteps, waveform_nn; markershape=:circle,
        -         markeralpha=0.25, alpha=0.5, strokewidth=2, markersize=12)
        - 
        -     l3 = lines!(ax, tsteps, waveform_nn_trained; linewidth=2, alpha=0.75)
        -     s3 = scatter!(ax, tsteps, waveform_nn_trained; markershape=:circle,
        -         markeralpha=0.25, alpha=0.5, strokewidth=2, markersize=12)
        - 
        -     axislegend(ax, [[l1, s1], [l2, s2], [l3, s3]],
        -         ["Waveform Data", "Waveform Neural Net (Untrained)", "Waveform Neural Net"];
        -         position=:lb)
        - 
        -     fig
        - end
        - ````
        - 
        - ```@raw html
        - <img width=600 height=450 style='object-fit: contain; height: auto;' src="data:image/png;base64, iVBORw0KGgoAAAANSUhEUgAABLAAAAOECAIAAAA+D1+tAAAABmJLR0QA/wD/AP+gvaeTAAAgAElEQVR4nOzdd3wUdfoH8Gdmtm96TyChh96RXgRBFBCxnlIs5ynYT9Tzd6ecZ4WTs+Gp2D0VUVGa6HGICILSIfSWQEJ6SE+2z8z398cmM5NkKQrZ3Ww+79e9Xved2Znsc6+9hHn2+3yfL8cYIwAAAAAAAGh9+EAHAAAAAAAAAIGBhBAAAAAAAKCVQkIIAAAAAADQSiEhBAAAAAAAaKWQEAIAAAAAALRSSAgBAAAAAABaKSSEAAAAAAAArRQSQgAAAAAAgFYKCSEAAAAAAEArhYQQAAAAAACglUJCCAAAAAAA0EohIQQAAAAAAGilkBACAAAAAAC0UkgIAQAAAAAAWikkhAAAAAAAAK0UEkIAAAAAAIBWCgkhAAAAAABAK4WEEAAAAAAAoJVCQggAAAAAANBKISEEAAAAAABopZAQAgAAAAAAtFJICAEAAAAAAFopJIQAAAAAAACtFBJCAAAAAACAVgoJIQAAAAAAQCuFhBAAAAAAAKCVQkIIAAAAAADQSiEhBAAAAAAAaKWQEAIAAAAAALRSSAgBAAAAAABaKV2gAwA/4Tgu0CEAAAAAAMBvxhhrvh+OGUIAAAAAAIBWCjOErUuzfrtwIWw2W1lZmdVqjY2NDWwkcDFcLldxcbHRaExMTAx0LPD7iaJYUFCg0+lSUlICHQtclNOnTxNRWlpaoAOBi1JQUCCKYkpKik6Hx7MWrLi42OVyJSYmGo3GQMcCv19ZWZnNZouNjbVarYGNxA9VfpghBAAAAAAAaKWQEAIAAAAAALRSSAgBAAAAAABaKSSEAAAAAAAArRQSQgAAAAAAgFYKCSEAAAAAAEArhYQQAAAAAACglUJCCAAAAA
        - ```
        - 
        - ## Appendix
        - 
        - ````julia
        - using InteractiveUtils
        - InteractiveUtils.versioninfo()
        - if @isdefined(LuxCUDA) && CUDA.functional(); println(); CUDA.versioninfo(); end
        - if @isdefined(LuxAMDGPU) && LuxAMDGPU.functional(); println(); AMDGPU.versioninfo(); end
        - ````
        - 
        - ````
        - Julia Version 1.10.2
        - Commit bd47eca2c8a (2024-03-01 10:14 UTC)
        - Build Info:
        -   Official https://julialang.org/ release
        - Platform Info:
        -   OS: Linux (x86_64-linux-gnu)
        -   CPU: 48 × AMD EPYC 7402 24-Core Processor
        -   WORD_SIZE: 64
        -   LIBM: libopenlibm
        -   LLVM: libLLVM-15.0.7 (ORCJIT, znver2)
        - Threads: 48 default, 0 interactive, 24 GC (on 2 virtual cores)
        - Environment:
        -   LD_LIBRARY_PATH = /usr/local/nvidia/lib:/usr/local/nvidia/lib64
        -   JULIA_DEPOT_PATH = /root/.cache/julia-buildkite-plugin/depots/01872db4-8c79-43af-ab7d-12abac4f24f6
        -   JULIA_PROJECT = /var/lib/buildkite-agent/builds/gpuci-11/julialang/lux-dot-jl/docs/Project.toml
        -   JULIA_AMDGPU_LOGGING_ENABLED = true
        -   JULIA_DEBUG = Literate
        -   JULIA_CPU_THREADS = 2
        -   JULIA_NUM_THREADS = 48
        -   JULIA_LOAD_PATH = @:@v#.#:@stdlib
        -   JULIA_CUDA_HARD_MEMORY_LIMIT = 25%
        - 
        - CUDA runtime 12.3, artifact installation
        - CUDA driver 12.4
        - NVIDIA driver 550.54.14
        - 
        - CUDA libraries: 
        - - CUBLAS: 12.3.4
        - - CURAND: 10.3.4
        - - CUFFT: 11.0.12
        - - CUSOLVER: 11.5.4
        - - CUSPARSE: 12.2.0
        - - CUPTI: 21.0.0
        - - NVML: 12.0.0+550.54.14
        - 
        - Julia packages: 
        - - CUDA: 5.2.0
        - - CUDA_Driver_jll: 0.7.0+1
        - - CUDA_Runtime_jll: 0.11.1+0
        - 
        - Toolchain:
        - - Julia: 1.10.2
        - - LLVM: 15.0.7
        - 
        - Environment:
        - - JULIA_CUDA_HARD_MEMORY_LIMIT: 25%
        - 
        - 1 device:
        -   0: NVIDIA A100-PCIE-40GB MIG 1g.5gb (sm_80, 4.735 GiB / 4.750 GiB available)
        - ┌ Warning: LuxAMDGPU is loaded but the AMDGPU is not functional.
        - └ @ LuxAMDGPU ~/.cache/julia-buildkite-plugin/depots/01872db4-8c79-43af-ab7d-12abac4f24f6/packages/LuxAMDGPU/sGa0S/src/LuxAMDGPU.jl:19
        - 
        - ````
        - 
        - ---
        - 
        - *This page was generated using [Literate.jl](https://github.com/fredrikekre/Literate.jl).*
        - 
